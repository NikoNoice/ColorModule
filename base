local ColorModule = {}

-- Color Configuration
local ColorConfig = {
    -- Animation settings
    Enabled = true,
    AnimationSpeed = 2, -- Speed multiplier for animations
    
    -- Wave settings (for perimeter animation)
    WaveEnabled = true,
    WaveSpeed = 2,
    WaveSize = 0.08, -- How pronounced the wave effect is
    WaveIntensity = 0.8, -- Blend intensity between base and wave color
    WaveSegments = 80, -- Number of segments around box perimeter
    
    -- Rainbow settings
    RainbowEnabled = true,
    RainbowSpeed = 1.5, -- How fast colors cycle
    RainbowSaturation = 1, -- Color intensity (0-1)
    RainbowBrightness = 1, -- Color brightness (0-1)
    
    -- Pulse settings
    PulseEnabled = true,
    PulseSpeed = 2,
    PulseIntensity = 0.3,
    
    -- Base colors
    BaseBoxColor = Color3.fromRGB(0, 170, 255),
    BaseWaveColor = Color3.fromRGB(255, 0, 255),
    BaseHealthbarColor = Color3.fromRGB(0, 255, 0),
    BaseTextColor = Color3.fromRGB(255, 255, 255),
    
    -- Color modes for different ESP elements
    BoxColorMode = "wave", -- "wave", "rainbow", "pulse", "static"
    HealthbarColorMode = "gradient", -- "rainbow", "gradient", "static"
    TextColorMode = "rainbow", -- "rainbow", "static"
    SkeletonColorMode = "rainbow", -- "rainbow", "wave", "static"
    
    -- Advanced settings
    SyncAnimations = false, -- Sync all animations to same timing
    IndividualPlayerColors = true, -- Each player gets different color offset
    DistanceColorEffect = false, -- Color changes based on distance
}

-- Internal variables
local startTime = tick()
local playerColorOffsets = {}
local waveTime = 0

-- Update wave time
game:GetService("RunService").Heartbeat:Connect(function(dt)
    waveTime = waveTime + dt
end)

-- Utility functions
local function HSVtoRGB(h, s, v)
    local r, g, b
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    
    i = i % 6
    
    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end
    
    return Color3.new(r, g, b)
end

local function lerpColor(color1, color2, alpha)
    return Color3.new(
        color1.R + (color2.R - color1.R) * alpha,
        color1.G + (color2.G - color1.G) * alpha,
        color1.B + (color2.B - color1.B) * alpha
    )
end

-- Get player-specific color offset
local function getPlayerOffset(player)
    if not ColorConfig.IndividualPlayerColors then
        return 0
    end
    
    if not playerColorOffsets[player] then
        -- Generate consistent offset based on player's name for persistence
        local nameHash = 0
        for i = 1, #player.Name do
            nameHash = nameHash + string.byte(player.Name, i)
        end
        playerColorOffsets[player] = (nameHash % 360) / 360
    end
    
    return playerColorOffsets[player]
end

-- Main wave color function (like the original script)
function ColorModule:GetWaveColor(baseColor, waveColor, position, totalPerimeter, player, colorMode)
    colorMode = colorMode or ColorConfig.BoxColorMode
    
    if not ColorConfig.Enabled then
        return baseColor
    end
    
    local playerOffset = getPlayerOffset(player)
    local timeOffset = ColorConfig.SyncAnimations and 0 or (playerOffset * 10)
    local currentTime = waveTime + timeOffset
    
    local f = 0
    
    if colorMode == "wave" and ColorConfig.WaveEnabled then
        -- Wave effect (like the original script)
        local angle = (position / totalPerimeter) * math.pi * 2 * 3 + currentTime * ColorConfig.WaveSpeed * 3
        f = (math.sin(angle) * ColorConfig.WaveSize + ColorConfig.WaveSize) / (ColorConfig.WaveSize * 2)
        f = math.clamp(f, 0, 1) ^ ColorConfig.WaveIntensity
        return lerpColor(baseColor, waveColor, f)
        
    elseif colorMode == "pulse" and ColorConfig.PulseEnabled then
        -- Pulse effect
        f = (math.sin(currentTime * ColorConfig.PulseSpeed * 2) + 1) / 2
        return lerpColor(baseColor, waveColor, f * ColorConfig.PulseIntensity)
        
    elseif colorMode == "rainbow" and ColorConfig.RainbowEnabled then
        -- Rainbow effect that flows around the perimeter
        local hue = (((position / totalPerimeter) + currentTime * ColorConfig.RainbowSpeed) % 1)
        return HSVtoRGB(hue, ColorConfig.RainbowSaturation, ColorConfig.RainbowBrightness)
    end
    
    return baseColor
end

-- Generate colors for segmented box perimeter
function ColorModule:GetPerimeterColors(player, boxWidth, boxHeight, segments)
    if not ColorConfig.Enabled then
        local color = ColorConfig.BaseBoxColor
        local colors = {}
        for i = 1, segments do
            colors[i] = color
        end
        return colors
    end
    
    segments = segments or ColorConfig.WaveSegments
    local totalPerimeter = 2 * (boxWidth + boxHeight)
    local colors = {}
    
    -- Calculate position along perimeter for each segment
    local sideSegs = math.floor(segments / 4)
    local segmentPositions = {}
    
    -- Top edge
    for i = 0, sideSegs - 1 do
        local pos = (i / sideSegs) * boxWidth
        table.insert(segmentPositions, pos)
    end
    
    -- Right edge
    for i = 0, sideSegs - 1 do
        local pos = boxWidth + (i / sideSegs) * boxHeight
        table.insert(segmentPositions, pos)
    end
    
    -- Bottom edge
    for i = 0, sideSegs - 1 do
        local pos = boxWidth + boxHeight + (i / sideSegs) * boxWidth
        table.insert(segmentPositions, pos)
    end
    
    -- Left edge
    for i = 0, sideSegs - 1 do
        local pos = 2 * boxWidth + boxHeight + (i / sideSegs) * boxHeight
        table.insert(segmentPositions, pos)
    end
    
    -- Generate colors for each segment
    for i, position in ipairs(segmentPositions) do
        colors[i] = self:GetWaveColor(
            ColorConfig.BaseBoxColor,
            ColorConfig.BaseWaveColor,
            position,
            totalPerimeter,
            player,
            ColorConfig.BoxColorMode
        )
    end
    
    return colors
end

-- Standard color getters for other ESP elements
function ColorModule:GetBoxColor(player, distance, maxDistance)
    if not ColorConfig.Enabled then
        return ColorConfig.BaseBoxColor
    end
    
    local timeOffset = ColorConfig.SyncAnimations and 0 or (getPlayerOffset(player) * 10)
    
    if ColorConfig.BoxColorMode == "rainbow" and ColorConfig.RainbowEnabled then
        local currentTime = waveTime + timeOffset
        local hue = ((currentTime * ColorConfig.RainbowSpeed) % 1)
        return HSVtoRGB(hue, ColorConfig.RainbowSaturation, ColorConfig.RainbowBrightness)
    elseif ColorConfig.BoxColorMode == "pulse" and ColorConfig.PulseEnabled then
        local currentTime = waveTime + timeOffset
        local pulse = (math.sin(currentTime * ColorConfig.PulseSpeed * 2) + 1) / 2
        return lerpColor(ColorConfig.BaseBoxColor, ColorConfig.BaseWaveColor, pulse * ColorConfig.PulseIntensity)
    end
    
    return ColorConfig.BaseBoxColor
end

function ColorModule:GetHealthbarColor(player, healthPercentage, distance, maxDistance)
    if not ColorConfig.Enabled then
        return ColorConfig.BaseHealthbarColor
    end
    
    local timeOffset = ColorConfig.SyncAnimations and 0 or (getPlayerOffset(player) * 10)
    
    if ColorConfig.HealthbarColorMode == "rainbow" and ColorConfig.RainbowEnabled then
        local currentTime = waveTime + timeOffset
        local hue = ((currentTime * ColorConfig.RainbowSpeed) % 1)
        return HSVtoRGB(hue, ColorConfig.RainbowSaturation, ColorConfig.RainbowBrightness)
    elseif ColorConfig.HealthbarColorMode == "gradient" then
        -- Health-based gradient (red to green)
        local lowColor = Color3.fromRGB(255, 0, 0)
        local highColor = Color3.fromRGB(0, 255, 0)
        return lerpColor(lowColor, highColor, healthPercentage)
    end
    
    return ColorConfig.BaseHealthbarColor
end

function ColorModule:GetTextColor(player, distance, maxDistance)
    if not ColorConfig.Enabled then
        return ColorConfig.BaseTextColor
    end
    
    local timeOffset = ColorConfig.SyncAnimations and 0 or (getPlayerOffset(player) * 10)
    
    if ColorConfig.TextColorMode == "rainbow" and ColorConfig.RainbowEnabled then
        local currentTime = waveTime + timeOffset
        local hue = ((currentTime * ColorConfig.RainbowSpeed) % 1)
        return HSVtoRGB(hue, ColorConfig.RainbowSaturation, ColorConfig.RainbowBrightness)
    end
    
    return ColorConfig.BaseTextColor
end

function ColorModule:GetSkeletonColor(player, partIndex, distance, maxDistance)
    if not ColorConfig.Enabled then
        return ColorConfig.BaseBoxColor
    end
    
    local timeOffset = ColorConfig.SyncAnimations and 0 or ((getPlayerOffset(player) * 10) + (partIndex or 0) * 0.5)
    
    if ColorConfig.SkeletonColorMode == "rainbow" and ColorConfig.RainbowEnabled then
        local currentTime = waveTime + timeOffset
        local hue = ((currentTime * ColorConfig.RainbowSpeed) % 1)
        return HSVtoRGB(hue, ColorConfig.RainbowSaturation, ColorConfig.RainbowBrightness)
    elseif ColorConfig.SkeletonColorMode == "wave" and ColorConfig.WaveEnabled then
        return self:GetWaveColor(
            ColorConfig.BaseBoxColor,
            ColorConfig.BaseWaveColor,
            (partIndex or 0) * 50, -- Fake perimeter position
            300, -- Fake total perimeter
            player,
            "wave"
        )
    end
    
    return ColorConfig.BaseBoxColor
end

-- Configuration functions
function ColorModule:UpdateConfig(newConfig)
    for key, value in pairs(newConfig) do
        if ColorConfig[key] ~= nil then
            ColorConfig[key] = value
        end
    end
end

function ColorModule:GetConfig()
    return ColorConfig
end

-- Convenience setters
function ColorModule:SetWaveSpeed(speed)
    ColorConfig.WaveSpeed = speed
end

function ColorModule:SetRainbowSpeed(speed)
    ColorConfig.RainbowSpeed = speed
end

function ColorModule:SetWaveIntensity(intensity)
    ColorConfig.WaveIntensity = intensity
end

function ColorModule:SetWaveSize(size)
    ColorConfig.WaveSize = size
end

function ColorModule:EnableWave(enabled)
    ColorConfig.WaveEnabled = enabled
end

function ColorModule:EnableRainbow(enabled)
    ColorConfig.RainbowEnabled = enabled
end

function ColorModule:SetBoxColorMode(mode)
    -- "wave", "rainbow", "pulse", "static"
    ColorConfig.BoxColorMode = mode
end

function ColorModule:SetIndividualPlayerColors(enabled)
    ColorConfig.IndividualPlayerColors = enabled
end

-- Cleanup function
function ColorModule:CleanupPlayer(player)
    playerColorOffsets[player] = nil
end

-- Reset function
function ColorModule:Reset()
    startTime = tick()
    waveTime = 0
    playerColorOffsets = {}
end


ColorModule.Version = "1.0.1"
ColorModule.Author = "nikonovice"
ColorModule.Description = "Hey"


return ColorModule
